<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Freitag, Juli 28, 2017, 12:55  -->
<!-- MuClient version 5.05 -->

<!-- Plugin "Configuration" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Configuration"
   author="Toni Barth"
   id="741d5052da64c6ec33c863e5"
   language="Lua"
   purpose="A configuration tool which stores configuration data inside an ini file and makes stuff configurable"
   save_state="n"
   date_written="2017-07-28 12:54:55"
   requires="5.05"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   match="^config ?([\w|\d]+)? ?(.*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
  >
  <send>ConfigCommand("%1", "%2")</send>
  </alias>
</aliases>


<!--  Script  -->


<script>
<![CDATA[
Config = {}
Configurables = {}
Ini = require('ini')
PPI = require('ppi')
String = require('pl.stringx')
Table = require('pl.tablex')

-- constants follow
TYPE_BOOL = 'bool'
TYPE_NUMBER = 'number'
TYPE_PERCENTAGE = 'percentage'
TYPE_TEXT = 'text'

function Load()

  local ctbl = Ini.read('config.dat')

  if ctbl then
    for name, section in pairs(ctbl) do
      for optionname, optionvalue in pairs(section) do
        config = tonumber(optionvalue)
        if config == nil then
          config = optionvalue
        end
        if Config[name] == nil then
          Config[name] = {}
        end
        Config[name][optionname] = config
      end
    end
  end

end

function Unload()
  if Table.size(Config) > 0 then
    Ini.write('config.dat', Config)
  end

  for option, config in pairs(Configurables) do

    if config.type == TYPE_BOOL and config.key ~= nil then
      world.Accelerator(config.key, '')
    end
  end

end

function OnPluginClose()

  Unload()

end

function Set(section, option, value)

  if Config[section] == nil then
    Config[section] = {}
  end

  Config[section][option] = value

end

function Get(section, option)

  if Config[section] == nil then
    return nil
  end

  return Config[section][option]

end

-- configurables can be configured ingame via the config command
-- section and option relate to the corresponding value inside the Config table
-- type can be one of the following:
--   int (any kind of integer)
--   percentage (integer, but only 0 to 100)
--   bool (true or false / on or off only)
--   text (any given text will be accepted as valid)
-- description will be the text displayed when entering only config (without arguments)
-- if func is given, we won't do any type checks ever
-- the given function will be called instead with the following parameters:
--   section, option, value, where the value is the value the user wants to set
-- the return value will be saved into the configuration
-- if nil is returned, the current value won't be changed
-- if key is given, an accelerator with this key will be added to boolean configurables
function AddConfigurable(arg)

  -- make sure the type is valid
  if arg.func == nil and Table.find({TYPE_BOOL, TYPE_NUMBER, TYPE_PERCENTAGE, TYPE_TEXT}, arg.type) == nil then
    error(arg.type..' is no valid configurable type')
  end

  -- make sure the section and the option exist
  if Config[arg.section] == nil or Config[arg.section][arg.option] == nil then
    if arg.type == TYPE_TEXT then
      Set(arg.section, arg.option, '')
    else
      Set(arg.section, arg.option, 0)
    end
  end

  -- and we don't actually got an option with this name
  if Configurables[arg.option:lower()] ~= nil then
    error('configurable '..arg.option:lower()..' already exists')
  end

  -- if we got a function, we will remove the type
  if arg.func ~= nil then
    arg.type = nil
  end

  -- we will add it to the table
  Configurables[arg.option:lower()] = {
    section = arg.section,
    option = arg.option,
    type = arg.type,
    description = arg.description,
    func = arg.func,
    key = arg.key
  }

  if arg.type == TYPE_BOOL and arg.key ~= nil then
    world.Accelerator(arg.key, 'config '..arg.option:lower()..' toggle')
  end

end

-- returns the current configurable value properly formatted
function GetConfigurableValue(option)

  if Configurables[option] == nil then
    return
  end

  local result = Config[Configurables[option].section][Configurables[option].option]

  if Configurables[option].type == TYPE_TEXT then
    result = tostring(result)
  elseif Configurables[option].type == TYPE_NUMBER then
    result = tonumber(result)
  elseif Configurables[option].type == TYPE_PERCENTAGE then
    result = tonumber(result)
    if tonumber(result) <0 then
      result = 0
    elseif tonumber(result) > 100 then
      result = 100
    end
  elseif Configurables[option].type == TYPE_BOOL then
    if result == 0 then
      result = false
    else
      result = true
    end
  end

  return result

end

function GetConfigurableRepresentation(option)

  local result = GetConfigurableValue(option)

  if Configurables[option].type == TYPE_BOOL then
    if result == true then
      result = 'on'
    else
      result = 'off'
    end
  end

  return result
end

function ListConfigurables()

  world.Note('Configuration')

  world.Note('The following options are available:')

  local options = Table.keys(Configurables)

  for i, option in pairs(options) do

    local value = GetConfigurableRepresentation(option)

    world.Note(option..' ('..value..'): '..Configurables[option].description)

  end

end

function InformConfigurable(option)

  if Configurables[option] == nil then
    world.Note('Option '..option..' not found')
    return
  end

  world.Note(option)
  world.Note(Configurables[option].description)

  world.Note('Current state: '..tostring(GetConfigurableRepresentation(option)))

  if Configurables[option].key ~= nil then
    world.Note('You can toggle this option using '..Configurables[option].key..' too.')
  end

end

function SetConfigurable(option, value)

  local set
  local operator

  if Configurables[option] == nil then
    world.Note('Option '..option..' not found')
    return
  end

  -- you can define own types by adding a function to it
  if Configurables[option].func ~= nil then
    set = Configurables[option].func(Configurables[option].section, Configurables[option].option, value)
    if set ~= nil then
      Config[Configurables[option].section][Configurables[option].option]=set
    end
    return
  end

  -- we will handle everything with valid text input first
  if Configurables[option].type == TYPE_TEXT then
    Config[Configurables[option].section][Configurables[option].option]=value
    set = value
  elseif Configurables[option].type == TYPE_BOOL then
    if value == 'off' then
      Config[Configurables[option].section][Configurables[option].option]=0
      set = value
    elseif value == 'on' then
      Config[Configurables[option].section][Configurables[option].option]=1
      set = value
    elseif value == 'toggle' then
      if Config[Configurables[option].section][Configurables[option].option] == 0 then
        set = 'on'
        Config[Configurables[option].section][Configurables[option].option] = 1
      else
        set = 'off'
        Config[Configurables[option].section][Configurables[option].option] = 0
      end
    else
      world.Note('You can only toggle this option, or set it to on or off.')
      return
    end
  else
    -- all numeric values go here

    -- we will have to check for relative incrementation
    if value:sub(1,1) == '+' or value:sub(1,1) == '-' then
      operator = value:sub(1,1)
      value = value:sub(2)
    end

    value = tonumber(value)

    if value == nil then
      world.Note('You need to specify a numeric value.')
      return
    end

    if Configurables[option].type == TYPE_NUMBER then
      if operator == '+' then
        Config[Configurables[option].section][Configurables[option].option]=Config[Configurables[option].section][Configurables[option].option] + value
      elseif operator == '-' then
        Config[Configurables[option].section][Configurables[option].option]=Config[Configurables[option].section][Configurables[option].option] - value
      else
        Config[Configurables[option].section][Configurables[option].option] = value
      end
      set = tostring(Config[Configurables[option].section][Configurables[option].option])
    elseif Configurables[option].type == TYPE_PERCENTAGE then

      if operator == '+' then
        if Config[Configurables[option].section][Configurables[option].option] == 100 then
          world.Note(option..' already at 100%')
          return
        end
        Config[Configurables[option].section][Configurables[option].option] = math.min(100, Config[Configurables[option].section][Configurables[option].option] + value)
      elseif operator == '-' then
        if Config[Configurables[option].section][Configurables[option].option] == 0 then
          world.Note(option..' already at 0%')
          return
        end
        Config[Configurables[option].section][Configurables[option].option] = math.max(0, Config[Configurables[option].section][Configurables[option].option] + value)
      else
        if value < 0 or value > 100 then
          world.Note('Value out of range. You need to specify a value between 0 and 100.')
          return
        end

        Config[Configurables[option].section][Configurables[option].option]=value
      end

      set = tostring(Config[Configurables[option].section][Configurables[option].option])..'%'

    end
  end

  world.Note(option..' set to '..set)

end

-- this function will receive all input from the client
function ConfigCommand(option, value)

  if option == '' then
    -- we will only list all the available commands
    ListConfigurables()
    return
  end

  option = option:lower()

  if value == '' then
    InformConfigurable(option)
    return
  end

  SetConfigurable(option, String.strip(value))

end

PPI.Expose('AddConfigurable', AddConfigurable)
PPI.Expose('Get', Get)
PPI.Expose('Load', Load)
PPI.Expose('Set', Set)
PPI.Expose('Unload', Unload)

]]>
</script>


</muclient>
