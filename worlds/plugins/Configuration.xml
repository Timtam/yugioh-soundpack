<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Freitag, Juli 28, 2017, 12:55  -->
<!-- MuClient version 5.05 -->

<!-- Plugin "Configuration" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Configuration"
   author="Toni Barth"
   id="741d5052da64c6ec33c863e5"
   language="Lua"
   purpose="A configuration tool which stores configuration data inside an ini file and makes stuff configurable"
   save_state="n"
   date_written="2017-07-28 12:54:55"
   requires="5.05"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Aliases  -->

<aliases>
  <alias
   match="^config ?([\w|\d]+)? ?(.*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
  >
  <send>ConfigCommand("%1", "%2")</send>
  </alias>
</aliases>


<!--  Script  -->


<script>
<![CDATA[
Config = {}
Configurables = {}
Ini = require('ini')
PPI = require('ppi')
Table = require('pl.tablex')

-- constants follow
TYPE_BOOL = 'bool'
TYPE_INTEGER = 'int'
TYPE_PERCENTAGE = 'percentage'
TYPE_TEXT = 'text'

function Load()

    local ctbl = Ini.read('config.dat')

  if ctbl then
    for name, section in pairs(ctbl) do
      for optionname, optionvalue in pairs(section) do
        config = tonumber(optionvalue)
        if config == nil then
          config = optionvalue
        end
        if Config[name] == nil then
          Config[name] = {}
        end
        Config[name][optionname] = config
      end
    end
  end

end

function Unload()
  if Table.size(Config) > 0 then
    Ini.write('config.dat', Config)
  end

end

function OnPluginClose()

  Unload()

end

function Set(section, option, value)

  if Config[section] == nil then
    Config[section] = {}
  end

  Config[section][option] = value

end

function Get(section, option)

  if Config[section] == nil then
    return nil
  end

  return Config[section][option]

end

-- configurables can be configured ingame via the config command
-- section and option relate to the corresponding value inside the Config table
-- type can be one of the following:
--   int (any kind of integer)
--   percentage (integer, but only 0 to 100)
--   bool (true or false / on or off only)
--   text (any given text will be accepted as valid)
-- description will be the text displayed when entering only config (without arguments)
-- if func is given, we won't do any type checks ever
-- the given function will be called instead with the following parameters:
--   section, option, value, where the value is the value the user wants to set
-- the return value will be saved into the configuration
-- if nil is returned, the current value won't be changed
function AddConfigurable(section, option, type, description, func)

  -- make sure the type is valid
  if func == nil and Table.find({TYPE_BOOL, TYPE_INTEGER, TYPE_PERCENTAGE, TYPE_TEXT}, type) == nil then
    error(type..' is no valid configurable type')
  end

  -- make sure the section and the option exist
  if Config[section] == nil or Config[section][option] == nil then
    if type == TYPE_TEXT then
      Set(section, option, '')
    else
      Set(section, option, 0)
    end
  end

  -- and we don't actually got an option with this name
  if Configurables[option:lower()] ~= nil then
    error('configurable '..option:lower()..' already exists')
  end

  -- we will add it to the table
  Configurables[option:lower()] = {
    section = section,
    option = option,
    type = type,
    description = description,
    func = func
  }

end

-- returns the current configurable value properly formatted
function GetConfigurableValue(option)

  if Configurables[option] == nil then
    return
  end

  local result = Config[Configurables[option].section][Configurables[option].option]

  if Configurables[option].type == TYPE_TEXT then
    result = tostring(result)
  elseif Configurables[option].type == TYPE_INTEGER then
    result = tonumber(result)
  elseif Configurables[option].type == TYPE_PERCENTAGE then
    result = tonumber(result)
    if tonumber(result) <0 then
      result = 0
    elseif tonumber(result) > 100 then
      result = 100
    end
  elseif Configurables[option].type == TYPE_BOOL then
    if result == 0 then
      result = false
    else
      result = true
    end
  end

  return result

end

function GetConfigurableRepresentation(option)

  local result = GetConfigurableValue(option)

  if Configurables[option].type == TYPE_BOOL then
    if result == true then
      result = 'on'
    else
      result = 'off'
    end
  end

  return result
end

function ListConfigurables()

  world.Note('Configuration')

  world.Note('The following options are available:')

  local options = Table.keys(Configurables)

  for i, option in pairs(options) do

    local value = GetConfigurableRepresentation(option)

    world.Note(option..' ('..value..'): '..Configurables[option].description)

  end

end

function InformConfigurable(option)

  if Configurables[option] == nil then
    world.Note('Option '..option..' not found')
    return
  end

  world.Note(option)
  world.Note(Configurables[option].description)

  world.Note('Current state: '..tostring(GetConfigurableRepresentation(option)))

end

function SetConfigurable(option, value)

  local set

  if Configurables[option] == nil then
    world.Note('Option '..option..' not found')
    return
  end

  -- you can define own types by adding a function to it
  if Configurables[option].func ~= nil then
    set = Configurables[option].func(Configurables[option].section, Configurables[option].option, value)
    if set ~= nil then
      Config[Configurables[option].section][Configurables[option].option]=set
    end
    return
  end

  -- we will handle everything with valid text input first
  if Configurables[option].type == TYPE_TEXT then
    Config[Configurables[option].section][Configurables[option].option]=value
    set = value
  elseif Configurables[option].type == TYPE_BOOL then
    if value == 'off' then
      Config[Configurables[option].section][Configurables[option].option]=0
      set = value
    elseif value == 'on' then
      Config[Configurables[option].section][Configurables[option].option]=1
      set = value
    elseif value == 'toggle' then
      if Config[Configurables[option].section][Configurables[option].option] == 0 then
        set = 'on'
        Config[Configurables[option].section][Configurables[option].option] = 1
      else
        set = 'off'
        Config[Configurables[option].section][Configurables[option].option] = 0
      end
    else
      world.Note('You can only toggle this option, or set it to on or off.')
      return
    end
  else
    -- all numeric values go here
    value = tonumber(value)

    if value == nil then
      world.Note('You need to specify a numeric value.')
      return
    end

    if Configurables[option].type == TYPE_INTEGER then
      Config[Configurables[option].section][Configurables[option].option]=value
      set = tostring(value)
    elseif Configurables[option].type == TYPE_PERCENTAGE then

      if value < 0 or value > 100 then
        world.Note('Value out of range. You need to specify a value between 0 and 100.')
        return
      end

      Config[Configurables[option].section][Configurables[option].option]=value

      set = tostring(value)..'%'

    end
  end

  world.Note(option..' set to '..set)

end

-- this function will receive all input from the client
function ConfigCommand(option, value)

  if option == '' then
    -- we will only list all the available commands
    ListConfigurables()
    return
  end

  option = option:lower()

  if value == '' then
    InformConfigurable(option)
    return
  end

  SetConfigurable(option, value)

end

PPI.Expose('AddConfigurable', AddConfigurable)
PPI.Expose('Get', Get)
PPI.Expose('Load', Load)
PPI.Expose('Set', Set)
PPI.Expose('Unload', Unload)

]]>
</script>


</muclient>
